# -*- coding: utf-8 -*-
"""EGNN_QM9.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1te0LTXoU8-dzaFZdUTgaSfFSlonteeuS
"""

import numpy as np
import pandas as pd
import torch
import torch.nn.functional as F
from torch_geometric.data import DataLoader, DataListLoader
from torch_geometric.nn import EGConv
from pyscf import gto, scf
from torch.utils.data import Dataset, DataLoader

from torch.utils.data import Dataset, DataLoader

# Define the EGNN architecture
class EGNN(torch.nn.Module):
    def __init__(self, dim, num_layers):
        super(EGNN, self).__init__()
        self.conv1 = EGConv(dim, dim)
        self.convs = torch.nn.ModuleList()
        for i in range(num_layers - 1):
            self.convs.append(EGConv(dim, dim))
        self.fc1 = torch.nn.Linear(dim, dim)
        self.fc2 = torch.nn.Linear(dim, 1)

    def forward(self, x, edge_index, edge_attr, batch):
        x = self.conv1(x, edge_index, edge_attr)
        for conv in self.convs:
            x = F.relu(conv(x, edge_index, edge_attr))
        x = torch_geometric.nn.global_mean_pool(x, batch)
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return x.squeeze(-1)


# Define a function to calculate the quadrupole moments of a molecule using PySCF
def calc_quadrupole_moments(molecule):
    mol = gto.M(atom=molecule, basis='sto-3g')
    mf = scf.RHF(mol)
    mf.kernel()
    dm = mf.make_rdm1()
    coords = mol.atom_coords()
    quadrupole_moments = []
    for i in range(3):
        for j in range(i, 3):
            quadrupole_moment = np.sum(dm * (3 * coords[:, i] * coords[:, j] - np.dot(coords, coords.T)))
            quadrupole_moments.append(quadrupole_moment)
    return quadrupole_moments


# Define a function to load the QM9 dataset and convert it to a PyTorch Geometric data object
def load_qm9_data():
    df = pd.read_csv('qm9/gdb9.sdf.csv')
    df = df.drop(columns=['Unnamed: 0', 'smiles'])
    df['quadrupole_moments'] = df['xyz'].apply(calc_quadrupole_moments)
    data_list = []
    for i in range(len(df)):
        x = torch.tensor(df['rdkitmol'][i].GetConformer().GetPositions(), dtype=torch.float)
        edge_index = None  # TODO: Define the edge index for your molecule
        edge_attr = None  # TODO: Define the edge attributes for your molecule
        y = torch.tensor(df['quadrupole_moments'][i], dtype=torch.float)
        data = torch_geometric.data.Data(x=x, edge_index=edge_index, edge_attr=edge_attr, y=y)
        data_list.append(data)
    return data_list

# Define a function to train an EGNN on the QM9 dataset
def train_egnn(data_list):
    train_loader = DataLoader(data_list, batch_size=32, shuffle=True)
    model = EGNN(dim=64, num_layers=4)
    optimizer = torch.optim.Adam(model.parameters(), lr=0.01)
    for epoch in range(10):
        model.train()
        total_loss = 0
        for data in train_loader:
            optimizer.zero_grad()
            out = model(data.x, data.edge_index, data.edge_attr, data.batch)
            loss = F.mse_loss(out, data.y)
            loss.backward()
            optimizer.step()
            total_loss += loss.item() * data.num_graphs
        print('Epoch {} | Loss: {:.4f}'.format(epoch + 1, total_loss / len(train_loader.dataset)))

# Define a dataset class for the QM9 dataset
class QM9Dataset(Dataset):
    def __init__(self, data_path):
        # Load the data from the given path
        data = torch.load(data_path)

        # Extract the node features, edge indices, and targets
        self.node_features = data["node_features"]
        self.edge_indices = data["edge_indices"]
        self.targets = data["targets"]

    def __len__(self):
        return len(self.targets)

    def __getitem__(self, idx):
        # Return the node features, edge indices, and targets for the given index
        return self.node_features[idx], self.edge_indices[idx], self.targets[idx]

# Define a function to train an EGNN on the QM9 dataset
def train_egnn(data_path, num_epochs=10, batch_size=64, lr=1e-3):
    # Create a dataset and dataloader for the QM9 dataset
    dataset = QM9Dataset(data_path)
    dataloader = DataLoader(dataset, batch_size=batch_size, shuffle=True)

    # Create an instance of the EGNN class
    model = EGNN(dim=64, num_layers=3)

    # Define the optimizer and loss function
    optimizer = torch.optim.Adam(model.parameters(), lr=lr)
    loss_fn = F.mse_loss

    # Train the model for the specified number of epochs
    for epoch in range(num_epochs):
        epoch_loss = 0.0
        for node_features, edge_indices, targets in dataloader:
            # Zero the gradients
            optimizer.zero_grad()

            # Forward pass
            output = model(node_features, edge_indices)

            # Compute the loss
            loss = loss_fn(output, targets)

            # Backward pass
            loss.backward()
            optimizer.step()

            epoch_loss += loss.item()

        print(f"Epoch {epoch+1}: Loss = {epoch_loss/len(dataset):.4f}")

    return model



"""# New Section"""